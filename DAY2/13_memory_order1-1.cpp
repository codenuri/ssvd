#include <atomic>

int a = 0;
int b = 0;

void foo()
{
    a = b + 1; 
    
    // 펜스 설치
    // "위 코드는 아래 펜스 아래로 내려갈수 없고"
    // "아래 코드는 펜스위로 올라 갈수 없다."
    // asm("mfence");

    // 아래 C++ 표준이 위 기계어 코드의 역활 입니다.
    // g++ 은 "lock xxx" 기계어로.. 
    std::atomic_thread_fence(std::memory_order_seq_cst);

    b = 1; // 실제 메모리가 변경되었는지
		   // 단지, CPU 의 캐쉬 안에만 변경 되었는지 확신할수 없습니다
		   // => 단일 스레드라면 캐쉬를 공유 하므로 문제 없지만
		   // => 다른 CPU 에서 수행되는 스레드가 메모리에 적용되지 않은 값을읽을수도 있습니다.
}

void goo()
{
    if (b == 1)
    {
        // a == 1 을 보장할수 있을까 ?   <<=== "A"
    }
}

// 위 코드는 펜스를 설치해서
// => "reordering" 문제는 해결했습니다

// 그런데, visiblity 문제가 있습니다.
// => "A" 위치는 보장 될수 없습니다.

// 해결책
// => int 가 아닌 std::atomic 으로 하면 됩니다.

// 멀티 스레드 동기화의 핵심 개념 3가지
// 1. 동시 접근에 대한 해결
// 2. reordering => 개발자가 만든 코드가 순서대로 실행되지 않을수 있다.
// 3. visibility => 하나의 스레드가 변경한 값을 정확히 다른 스레드가 읽을수 있는가 ?
//				    CPU 안의 캐쉬만 변경되고, 메모리에 적용되지 않으면 보장 안됨.

// 그럼, 지금까지의 동기화 예제는 문제 없나요 ?
// => 네, 완벽한 코드 입니다.
// => std::mutex 는 단순한 동시접근만의 해결이 아닙니다.
//    visibility 와 fence 개념을 모두 제공하는 도구 입니다.
//    m.unlock() => 이순간 캐쉬뿐 아니라 메모리 자체가 변경됨을 보장합니다.

// 결국, 최선은
// => 스레드간 공유되는 변수는 "int" 등을 사용하지 말고, std::atomic<int> 로하세요





